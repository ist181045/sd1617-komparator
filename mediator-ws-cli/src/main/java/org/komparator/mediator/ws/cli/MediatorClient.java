package org.komparator.mediator.ws.cli;

import static javax.xml.bind.DatatypeConverter.printBase64Binary;
import static javax.xml.ws.BindingProvider.ENDPOINT_ADDRESS_PROPERTY;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.ConnectException;
import java.net.SocketTimeoutException;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import javax.xml.ws.BindingProvider;
import javax.xml.ws.WebServiceException;

import org.komparator.mediator.ws.CartItemView;
import org.komparator.mediator.ws.CartView;
import org.komparator.mediator.ws.EmptyCart_Exception;
import org.komparator.mediator.ws.InvalidCartId_Exception;
import org.komparator.mediator.ws.InvalidCreditCard_Exception;
import org.komparator.mediator.ws.InvalidItemId_Exception;
import org.komparator.mediator.ws.InvalidQuantity_Exception;
import org.komparator.mediator.ws.InvalidText_Exception;
import org.komparator.mediator.ws.ItemIdView;
import org.komparator.mediator.ws.ItemView;
import org.komparator.mediator.ws.MediatorPortType;
import org.komparator.mediator.ws.MediatorService;
import org.komparator.mediator.ws.NotEnoughItems_Exception;
import org.komparator.mediator.ws.ShoppingResultView;
import org.komparator.security.SecurityManager;

import pt.ulisboa.tecnico.sdis.ws.uddi.UDDINaming;

/**
 * Client.
 * <p>
 * Adds easier endpoint address configuration and
 * UDDI lookup capability to the PortType generated by wsimport.
 */
public class MediatorClient implements MediatorPortType {

    /**
     * Max number of attempts after a timeout
     */
    private static final int MAX_NUM_OF_ATTEMPTS = 5;

    /**
     * Message id property
     */
    private static final String MESSAGE_ID_PROPERTY =
            "org.komparator.mediator.ws.message.id";

    /**
     * WS service
     */
    MediatorService service = null;

    /**
     * WS port (port type is the interface, port is the implementation)
     */
    MediatorPortType port = null;

    /**
     * UDDI server URL
     */
    private String uddiUrl = null;

    /**
     * WS name
     */
    private String wsName = null;

    /**
     * WS endpoint address
     */
    private String wsUrl = null; // default value is defined inside WSDL
    private int connectTimeout;
    private int receiveTimeout;
    /**
     * output option
     **/
    private boolean verbose = false;

    private int numOfAttempts = 0;

    /**
     * constructor with provided web service Url
     */
    public MediatorClient(String wsUrl) throws MediatorClientException {
        this(wsUrl, 5, 8);
    }

    /**
     * constructor with provided web service Url and timeouts
     */
    public MediatorClient(String wsUrl, int connectTimeout, int receiveTimeout)
            throws MediatorClientException {
        this.wsUrl = wsUrl;
        this.connectTimeout = connectTimeout;
        this.receiveTimeout = receiveTimeout;

        createStub();
        setTimeout(connectTimeout, receiveTimeout);
    }

    /**
     * constructor with provided UDDI location and name
     */
    public MediatorClient(String uddiUrl, String wsName)
            throws MediatorClientException {
        this(uddiUrl, wsName, 5, 8);
    }
    
    /**
     * constructor with provided UDDI location, name and timeouts
     */
    public MediatorClient(String uddiUrl, String wsName,
            int connectTimeout, int receiveTimeout)
            throws MediatorClientException {
        this.uddiUrl = uddiUrl;
        this.wsName = wsName;
        this.connectTimeout = connectTimeout;
        this.receiveTimeout = receiveTimeout;

        if (wsName != null)
            SecurityManager.getInstance().setReceiver(wsName);

        if (uddiUrl != null) {
            SecurityManager.getInstance().setSender("MediatorClient");
            uddiLookup();
        }

        createStub();
        setTimeout(connectTimeout, receiveTimeout);
    }

    /**
     * UDDI lookup
     */
    private void uddiLookup() throws MediatorClientException {
        try {
            if (verbose)
                System.out.printf("Contacting UDDI at %s%n", uddiUrl);
            UDDINaming uddiNaming = new UDDINaming(uddiUrl);

            if (verbose)
                System.out.printf("Looking for '%s'%n", wsName);
            wsUrl = uddiNaming.lookup(wsName);
        } catch (Exception e) {
            String msg = String.format("Client failed lookup on UDDI at %s!",
                    uddiUrl);
            throw new MediatorClientException(msg, e);
        }

        if (wsUrl == null) {
            String msg = String.format(
                    "Service with name %s not found on UDDI at %s", wsName,
                    uddiUrl);
            throw new MediatorClientException(msg);
        }
    }

    /**
     * Stub creation and configuration
     */
    private void createStub() {
        if (verbose)
            System.out.println("Creating stub ...");
        service = new MediatorService();
        port = service.getMediatorPort();

        if (wsUrl != null) {
            if (verbose)
                System.out.println("Setting endpoint address ...");
            BindingProvider bindingProvider = (BindingProvider) port;
            Map<String, Object> requestContext = bindingProvider
                    .getRequestContext();
            requestContext.put(ENDPOINT_ADDRESS_PROPERTY, wsUrl);
        }
    }
    
    /**
     * Setup connect and receive timeouts
     */
    private void setTimeout(int connectTimeout, int receiveTimeout) {
    	BindingProvider bindingProvider = (BindingProvider) port;
        Map<String, Object> requestContext = bindingProvider
                .getRequestContext();

        if (verbose)
            System.out.printf("Set connect timeout to %d second%s%n",
                    connectTimeout,
                    connectTimeout != 1 ? "s" : "");

        final List<String> CONN_TIME_PROPS = new ArrayList<>();
        CONN_TIME_PROPS.add("com.sun.xml.ws.connect.timeout");
        CONN_TIME_PROPS.add("com.sun.xml.internal.ws.connect.timeout");
        CONN_TIME_PROPS.add("javax.xml.ws.client.connectionTimeout");

        for (String propName : CONN_TIME_PROPS)
            requestContext.put(propName, connectTimeout * 1000);

        if (verbose)
            System.out.printf("Set connect timeout to %d second%s%n",
                    receiveTimeout,
                    receiveTimeout != 1 ? "s" : "");

        final List<String> RECV_TIME_PROPS = new ArrayList<>();
        RECV_TIME_PROPS.add("com.sun.xml.ws.request.timeout");
        RECV_TIME_PROPS.add("com.sun.xml.internal.ws.request.timeout");
        RECV_TIME_PROPS.add("javax.xml.ws.client.receiveTimeout");

        for (String propName : RECV_TIME_PROPS)
            requestContext.put(propName, receiveTimeout * 1000);
    }

    private synchronized void generateMessageId() {
        SecureRandom random = new SecureRandom();
        BindingProvider bindingProvider = (BindingProvider) port;
        Map<String, Object> requestContext = bindingProvider
                .getRequestContext();
        byte[] bytes = new byte[16];

        random.nextBytes(bytes);
        String messageId = printBase64Binary(bytes);
        requestContext.put(MESSAGE_ID_PROPERTY, messageId);
    }

    // remote invocation methods ----------------------------------------------

    /**
     * Wrapper method for <pre>doOperation</pre>.
     *
     * @see #doOperation(java.lang.Object...)
     */
    private <T> T doOperation(Object... args) throws Throwable {
        // Use current thread's stacktrace get the caller method's name, fragile
        // Also accounts for recursion.. incredibly fragile!!
        // reference: http://stackoverflow.com/a/421338/6506157
        String methodName = Thread.currentThread().getStackTrace()[2]
                .getMethodName();
        // Build array of types from args
        Class<?>[] types = Arrays.stream(args).map(Object::getClass)
                .collect(Collectors.toList()).toArray(new Class<?>[]{});
        return doOperation(methodName, types, args);
    }

    /**
     * Invokes a remote operation.
     *
     * Method called by every operation, handles connection timeouts, retrying
     * after a certain period of time after failure.
     *
     * @param methodName The method to invoke's name
     * @param types The types of the arguments
     * @param args The remote operation's arguments
     * @return The caller method's return type
     */
    private <T> T doOperation(String methodName, Class<?>[] types,
            Object... args) throws Throwable {
        try {
            Method method = port.getClass().getMethod(methodName, types);
            return (T)method.invoke(port, args);
        } catch (InvocationTargetException | WebServiceException e) {
            Throwable cause = e.getCause();

            if (cause != null && (cause instanceof SocketTimeoutException
                    || cause.getCause() instanceof SocketTimeoutException
                    || cause instanceof ConnectException
                    || cause.getCause() instanceof ConnectException)) {
                System.err.println("> Caused by a timeout!");

                if (++numOfAttempts == MAX_NUM_OF_ATTEMPTS) {
                    System.err.printf("> Number of attempts exceeded: %d%n",
                            numOfAttempts);
                    Thread.currentThread().interrupt();
                } else {
                    boolean foundMediator = false;
                    while (!foundMediator) {
                        try {
                            System.out.print("Sleeping.. ");
                            System.out.flush();

                            try {
                                Thread.sleep(5 * 1000);
                                System.out.print("Awake!");
                            } catch (InterruptedException ie) {
                                System.out.print("Interrupted!");
                            }
                            System.out.println(" Trying again..");

                            uddiLookup();
                            foundMediator = true;
                        } catch (MediatorClientException mce) {
                            System.err.println("Failed UDDI lookup");
                            numOfAttempts++;
                        }
                    }

                    BindingProvider bindingProvider = (BindingProvider) port;
                    Map<String, Object> requestContext = bindingProvider
                            .getRequestContext();
                    requestContext.put(ENDPOINT_ADDRESS_PROPERTY, wsUrl);

                    T result = doOperation(methodName, types, args);
                    numOfAttempts = 0;
                    return result;
                }
            } else {
                if (cause != null) throw cause;
                throw e;
            }
        } catch (NoSuchMethodException | IllegalAccessException rxe) {
            String error = "Something went horribly wrong! "
                    + "Get your methods right..";
            System.err.println(error);
            throw new RuntimeException(error, rxe);
        }

        return null;
    }

    @Override
    public void clear() {
        try {
            doOperation();
        } catch (Throwable throwable) {
            // ignored, shouldn't throw exception
        }
    }

    @Override
    public String ping(String arg0) {
        try {
            return doOperation(arg0);
        } catch (Throwable throwable) {
            // ignored, shouldn't throw exception
        }

        return null;
    }

    @Override
    public List<ItemView> searchItems(String descText)
            throws InvalidText_Exception {
        try {
            return doOperation(descText);
        } catch (Throwable throwable) {
            if (throwable instanceof InvalidText_Exception)
                throw (InvalidText_Exception)throwable;
        }

        return null;
    }

    @Override
    public List<CartView> listCarts() {
        try {
            return doOperation();
        } catch (Throwable throwable) {
            // ignored, shouldn't throw exception
        }

        return null;
    }

    @Override
    public List<ItemView> getItems(String productId)
            throws InvalidItemId_Exception {
        try {
            return doOperation(productId);
        } catch (Throwable throwable) {
            if (throwable instanceof InvalidItemId_Exception)
                throw (InvalidItemId_Exception)throwable;
        }

        return null;
    }

    @Override
    public ShoppingResultView buyCart(String cartId, String creditCardNr)
            throws EmptyCart_Exception, InvalidCartId_Exception,
            InvalidCreditCard_Exception {
        generateMessageId();
        try {
            return doOperation(cartId, creditCardNr);
        } catch (Throwable throwable) {
            if (throwable instanceof EmptyCart_Exception)
                throw (EmptyCart_Exception)throwable;
            if (throwable instanceof InvalidCartId_Exception)
                throw (InvalidCartId_Exception)throwable;
            if (throwable instanceof InvalidCreditCard_Exception)
                throw (InvalidCreditCard_Exception)throwable;
        }

        return null;
    }

    @Override
    public void addToCart(String cartId, ItemIdView itemId, int itemQty)
            throws InvalidCartId_Exception, InvalidItemId_Exception,
            InvalidQuantity_Exception, NotEnoughItems_Exception {
        generateMessageId();
        try {
            doOperation(itemId, itemQty);
        } catch (Throwable throwable) {
            if (throwable instanceof InvalidCartId_Exception)
                throw (InvalidCartId_Exception)throwable;
            if (throwable instanceof InvalidItemId_Exception)
                throw (InvalidItemId_Exception)throwable;
            if (throwable instanceof InvalidQuantity_Exception)
                throw (InvalidQuantity_Exception)throwable;
            if (throwable instanceof NotEnoughItems_Exception)
                throw (NotEnoughItems_Exception)throwable;
        }
    }

    @Override
    public List<ShoppingResultView> shopHistory() {
        try {
            return doOperation();
        } catch (Throwable throwable) {
            // ignored, shouldn't throw exception
        }

        return null;
    }

	@Override
	public void imAlive() {
		port.imAlive();
	}
	
	@Override
	public void updateShopHistory(String index, ShoppingResultView history) {
		port.updateShopHistory(index, history);
	}
	
	@Override
	public void updateCart(String cartID, List<CartItemView> items) {
		port.updateCart(cartID, items);
	}

}